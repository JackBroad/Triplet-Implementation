module test_regression
  !use mpi
  use mpi_variables
  use triplet_mod
  use tmpi_calcFullSimBoxEnergy_mod!, only: tmpi_calcFullSimBoxEnergy
  use tmpi_calcAtomMoveEnergy_mod!, only: tmpi_calcAtomMoveEnergy
  use GP_Variables
  use global_Flags, only: textOutput
  use energiesData_Module, only: energiesData
  use positionData_Module, only: positionData
  use funit
  implicit none
  include 'mpif.h'
  double precision :: regression_tolerance=1e-9, low_tol=5e-6
  double precision, allocatable :: posAt(:,:), Xd(:,:)
  double precision, allocatable :: expoData(:,:,:)
  integer, allocatable :: disMat(:,:)
  integer :: n_tri, n_at, n_dist

contains

  @test
  subroutine initialise_my_mpi()

    Character(len=300) :: hyperParametersFile = 'hyperParam.txt'
    Character(len=300) :: alphaFile = 'smallAlpha.txt'
    Character(len=300) :: trainingSetFile = 'smallTrainingSet.txt'

    textOutput = .false.
    
    call MPI_INIT(ierror)
    call MPI_COMM_SIZE(MPI_COMM_WORLD, clusterSize, ierror)
    call MPI_COMM_RANK(MPI_COMM_WORLD, processRank, ierror)
    call initialise_GP( hyperParametersFile, alphaFile, trainingSetFile )

    @assertEqual(root, 0 ,'Initialisation')
  end subroutine initialise_my_mpi
  !===========================================================================================



  @test
  subroutine test_JobsPerNode()
    integer:: nDist=3, nProc=1, nTrips=1
    integer:: distsPerProc, tripsPerProc


    if( processRank == root ) then
       print *,'========================Regression tests============================'
       print *,'If many tests fail, check that triplet_mod reads smallAlpha.txt and smallTrainingSet.txt'

       call getDistsAndTripletsPerProcNonAdd(nDist,nTrips,nProc,distsPerProc,tripsPerProc)
       @assertEqual(distsPerProc, 3,'Distances per processor #1')
       @assertEqual(tripsPerProc, 1,'Triplets per processor #1')


       !Build test!
       nDist=6
       nProc=2
       nTrips=4

       !Run calculation
       call getDistsAndTripletsPerProcNonAdd(nDist,nTrips,nProc,distsPerProc,tripsPerProc)

       ! check output
       @assertEqual(distsPerProc, 3 ,'Distances per processor #2')
       @assertEqual(tripsPerProc, 2,'Triplets per processor #2')

    end if

  end subroutine test_JobsPerNode



  @test
  subroutine test_initialise()
    implicit none
    character(len=40) :: name='AtomicPositionsTest.txt'
    double precision:: hyperParams_Ex(3), posAt_Ex(3,3)

    hyperParams_Ex(1:3) =  (/ 0.10109332178237054d0, 5.0651896159484985d-5, &
                            1.2319522830243570d-15 /)
    posAt_Ex(1,1:3) = (/ 2d0, 2d0, 2d0/)
    posAt_Ex(2,1:3) = (/ 4.598076211353316d0, 2d0, 0.5d0 /)
    posAt_Ex(3,1:3) = (/ 4.598076211353316d0, 2d0, 3.5d0 /)

    call initialise_Positions(name, posAt,n_at)
    call initialise_Variables(n_at, n_tri,n_dist)

    if( processRank == root ) then

       @assertEqual(N_tp, 3, 'Test initialise: no. of TPs')
       @assertEqual(hyperParams, hyperParams_Ex, regression_tolerance, 'Test initialise: hyperparameters')
       @assertEqual(n_at, 3, 'Test initialise: no. of atoms')
       @assertEqual(nArgs, 3, 'Test initialise: no. of arguments')
       @assertEqual(n_tri, 1, 'Test initialise: no. of triplets')
       @assertEqual(n_dist, 3, 'Test initialise: no. of distances in total')
       @assertEqual(posAt, posAt_Ex, regression_tolerance, 'Test initialise: atomic positions')

    end if

  end subroutine test_initialise

  @test
  subroutine test_Xdg()
    implicit none
    double precision :: Xdg(n_at,n_at), Xdg_Ex(n_at,n_at), ud_Ex(3)
    double precision, allocatable :: upperDiag(:)

    call makeXdgNonAdd(n_at,posAt, Xdg)
    call makeUDdgNonAdd(n_at,n_dist,Xdg, upperDiag)
    deallocate(posAt)

    if( processRank == root ) then

      Xdg_Ex(1,1:n_at) = (/ 0d0, (1d0/3d0), (1d0/3d0) /)
      Xdg_Ex(2,1:n_at) = (/ (1d0/3d0), 0d0, (1d0/3d0) /)
      Xdg_Ex(3,1:n_at) = (/ (1d0/3d0), (1d0/3d0), 0d0 /)

      @assertEqual(Xdg, Xdg_Ex, regression_tolerance, 'Test X_dg: delta-gamma matrix')

      ud_Ex = (/ (1d0/3d0), (1d0/3d0), (1d0/3d0) /)

      @assertEqual(upperDiag, ud_Ex, regression_tolerance, 'Test X_dg: upper diagonal')

    end if

  end subroutine test_Xdg

  @test
  subroutine test_disIntMat()
    implicit none
    integer :: disMat_Ex(n_at,n_at)

    disMat_Ex(1,1:n_at) = (/ 0, 1, 2 /)
    disMat_Ex(2,1:n_at) = (/ 1, 0, 3 /)
    disMat_Ex(3,1:n_at) = (/ 2, 3, 0 /)

    call makeDisIntMatNonAdd(n_at, disMat)

    if( processRank == root ) then

      @assertEqual(disMat, disMat_Ex, 'Test disIntMat')

    end if

  end subroutine test_disIntMat

  @test
  subroutine test_triMat()
    implicit none
    integer :: nTri=4, nAt=4
    integer, allocatable :: triMat_Ex(:,:), triMatrix(:,:)

    allocate(triMatrix(nArgs,nTri),triMat_Ex(nArgs,nTri))

    if( processRank == 0 ) then

      triMat_Ex(1:3,1) = (/1,2,3/)
      triMat_Ex(1:3,2) = (/1,2,4/)
      triMat_Ex(1:3,3) = (/1,3,4/)
      triMat_Ex(1:3,4) = (/2,3,4/)

      call makeTripletMatrix(nAt,nTri, triMatrix)

      @assertEqual(triMatrix, triMat_Ex, 'Test triplet matrix')

    end if

  end subroutine test_triMat

  @test
  subroutine test_scatter()
    implicit none
    integer :: bigVec(4), procVec(2), bigMat(2,2), root=0
    integer :: procVec_Ex(2)

    if( processRank == root ) then

      bigVec(1:4) = (/ 1,2,3,4 /)
      bigMat(1,1:2) = (/ 1,2 /)
      bigMat(2,1:2) = (/ 3,4 /)

    end if

    call MPI_Scatter(bigVec, 2, MPI_INT, procVec, 2, MPI_INT, root, MPI_COMM_WORLD, ierror)

    if( processRank == root ) then

      procVec_Ex(1) = 1
      procVec_Ex(2) = 2
      @assertEqual(procVec, procVec_Ex, 'Test scatter')

    else if( processRank == 1) then

      procVec_Ex(1) = 3
      procVec_Ex(2) = 4
      @assertEqual(procVec, procVec_Ex, 'Test scatter')

    end if

    call MPI_Scatter(bigMat, 2, MPI_INT, procVec, 2, MPI_INT, root, MPI_COMM_WORLD, ierror)

    if( processRank == root ) then

      procVec_Ex(1) = 1
      procVec_Ex(2) = 3
      @assertEqual(procVec, procVec_Ex, 'Test scatter')

    else if( processRank == 1) then

      procVec_Ex(1) = 2
      procVec_Ex(2) = 4
      @assertEqual(procVec, procVec_Ex, 'Test scatter')

    end if

  end subroutine test_scatter

  @test
  subroutine test_gather()
    implicit none
    integer :: bigMat(3,2), procVec(3), bigMat_Ex(3,2)

    if( processRank == root) then

      procVec(1) = 1
      procVec(2) = 2
      procVec(3) = 3

    else if( processRank == 1) then

      procVec(1) = 4
      procVec(2) = 5
      procVec(3) = 6

    end if

    bigMat_Ex(1,1:2) = (/ 1,4 /)
    bigMat_Ex(2,1:2) = (/ 2,5 /)
    bigMat_Ex(3,1:2) = (/ 3,6 /)

    call MPI_Gather(procVec, 3, MPI_INT, bigMat, 3, MPI_INT, root, MPI_COMM_WORLD, ierror)

    if( processRank == root) then

      @assertEqual(bigMat, bigMat_Ex, 'Test gather')

    end if

  end subroutine test_gather

  @test
  subroutine test_exp_calc()
    implicit none
    integer :: nDists=3
    double precision :: expSlice_Ex(nArgs,3)
    double precision :: expSlice(nArgs,3), dists(3)

    allocate(expoData(nArgs,N_tp,3))

    ! All distances in test triplet are 3 A
    dists = (/ 1d0/3d0,1d0/3d0,1d0/3d0 /)

    ! Pre-calculated exponenitals for dists with first TP
    expSlice_Ex(1,:) = (/ 0.5039746,0.5039746,0.5039746 /)
    expSlice_Ex(2,:) = (/ 0.2165715,0.2165715,0.2165715 /)
    expSlice_Ex(3,:) = (/ 0.1450487,0.1450487,0.1450487 /)

    ! Calculate exponentials w/ appropriate subroutine
    call calculateExponentialsNonAdd(nDists,N_tp,nArgs,trainData,hyperParams(1), &
                                     dists, expoData)

    ! Take slice of expoData which has exps with first TP
    expSlice = expoData(:,1,:)

    if( processRank == root) then

      @assertEqual(expSlice, expSlice_Ex, low_tol, 'Test exponential calc')

    end if

  end subroutine test_exp_calc

  @test
  subroutine test_triplet_energies()
    implicit none
    integer :: trip(3,1), Perm(6,3), N_p=6
    double precision :: U_Ex(1), U(1)

    U_Ex(1) = 68.776748653803210
    trip(:,1) = (/ 1,2,3 /)

    Perm(1,:) = (/1, 2, 3/)
    Perm(2,:) = (/1, 3, 2/)
    Perm(3,:) = (/2, 1, 3/)
    Perm(4,:) = (/2, 3, 1/)
    Perm(5,:) = (/3, 1, 2/)
    Perm(6,:) = (/3, 2, 1/)

    call tripletEnergiesNonAdd(trip,disMat,1,N_tp,n_at,N_p,nArgs,Perm, &
                               n_dist,expoData,alpha,hyperParams(2), U)

    if( processRank == root) then

      @assertEqual(U, U_Ex, low_tol, 'Test non-add energy single')

    end if

  end subroutine test_triplet_energies

  @test
  subroutine test_cluster_energies_and_move()
    implicit none
    character(len=40) :: name='AtomicPositions5.txt'
    double precision, allocatable  :: tripDist(:,:)
    double precision :: uVec_Ex(10)
    integer :: triplets(3,10), Perm(6,3)
    integer :: i
    type (energiesData) :: currentEnergies, proposedEnergies
    type (positionData) :: currentPosition

    Perm(1,:) = (/1, 2, 3/)
    Perm(2,:) = (/1, 3, 2/)
    Perm(3,:) = (/2, 1, 3/)
    Perm(4,:) = (/2, 3, 1/)
    Perm(5,:) = (/3, 1, 2/)
    Perm(6,:) = (/3, 2, 1/)

    triplets(:,1) = (/ 1,2,3 /)
    triplets(:,2) = (/ 1,2,4 /)
    triplets(:,3) = (/ 1,2,5 /)
    triplets(:,4) = (/ 1,3,4 /)
    triplets(:,5) = (/ 1,3,5 /)
    triplets(:,6) = (/ 1,4,5 /)
    triplets(:,7) = (/ 2,3,4 /)
    triplets(:,8) = (/ 2,3,5 /)
    triplets(:,9) = (/ 2,4,5 /)
    triplets(:,10) = (/ 3,4,5 /)

    call initialise_Positions(name, currentPosition%posArray,currentPosition%N_a)
    call initialise_Variables(currentPosition%N_a, currentPosition%N_tri, currentPosition%N_distances)
                               
    currentEnergies = tmpi_calcFullSimBoxEnergy(currentPosition)

    uVec_Ex = (/ -36.447687049554496,-42.826746144585805,-115.37904762300680, &
                 -39.315816583964079,-35.145291686734041,-40.420576004505804, &
                 -57.148919337879079,-87.423280140314134,-110.11337614380483, &
                 -50.353330971893016  /)

    if( processRank == root) then

        @assertEqual( currentEnergies%tripletEnergies, uVec_Ex, low_tol, 'Test full non-add energy')

    end if

    ! Find E when atom moved
    call tmpi_calcAtomMoveEnergy(1,1d0,currentPosition%N_a,currentPosition%N_distances,currentPosition%N_tri, &
                                 currentEnergies,currentPosition%posArray, proposedEnergies)

    ! Set up new vector of trip energies for comparison
    allocate(tripDist(3,currentPosition%N_tri))
    call findChangedDistsPerTrip(currentPosition%N_a,currentPosition%N_tri,triplets, &
                                 proposedEnergies%interatomicDistances, tripDist) ! Distances in each triplet after move
    do i = 1, currentPosition%N_tri
      
      uVec_Ex(i) = energyCheckCalc(tripDist(:,i)) ! Energies of each triplet after move

    end do

    if( processRank == root) then

      @assertEqual( proposedEnergies%tripletEnergies, uVec_Ex, low_tol, 'Test atom move energy')

    end if

  end subroutine test_cluster_energies_and_move

  @test
  subroutine test_v_setup()
    implicit none
    integer :: nP, nD=11, max, re, max_Ex, re_Ex
    integer, allocatable :: c(:), s(:), c_Ex(:), s_Ex(:)

    nP = 3
    allocate(c(nP),s(nP),c_Ex(nP),s_Ex(nP))

    max_Ex = 3
    re_Ex = 5

    call getNPerProcNonAdd(nD,nP, max,re)

    if( processRank == root) then

      @assertEqual(max, max_Ex, 'Test v setup max elements #1')
      @assertEqual(re, re_Ex, 'Test v setup re elements #1')

    end if

    c_Ex = (/ 3,3,5 /)
    s_Ex = (/ 0,3,6 /)

    call getVarrays(nP,max,re, c,s)

    if( processRank == root) then

      @assertEqual(c, c_Ex, 'Test v setup scounts #1')
      @assertEqual(s, s_Ex, 'Test v setup displs #1')

    end if

    deallocate(c,s,c_Ex,s_Ex)

    nP = 6
    allocate(c(nP),s(nP),c_Ex(nP),s_Ex(nP))

    max_Ex = 1
    re_Ex = 6

    call getNPerProcNonAdd(nD,nP, max,re)

    if( processRank == root) then

       @assertEqual(max, max_Ex, 'Test v setup max elements #2')
       @assertEqual(re, re_Ex, 'Test v setup re elements #2')

    end if

    c_Ex = (/ 1,1,1,1,1,6 /)
    s_Ex = (/ 0,1,2,3,4,5 /)

    call getVarrays(nP,max,re, c,s)

    if( processRank == root) then

      @assertEqual(c, c_Ex, 'Test v setup scounts #2')
      @assertEqual(s, s_Ex, 'Test v setup displs #2')

    end if

    deallocate(c,s,c_Ex,s_Ex)

  end subroutine test_v_setup

  @test
  subroutine test_exp_extract()
    implicit none
    character(len=40) :: name='AtomicPositions5.txt'
    integer :: nAt, mover, nTri, nDist, i
    integer, allocatable :: indices(:,:), ind_Ex(:,:)
    double precision, allocatable :: position(:,:)
    double precision, allocatable :: dists(:), dis_Ex(:)

    call initialise_Positions(name, position,nAt)
    call initialise_Variables(nAt, nTri,nDist)

    allocate(indices(2,nAt-1),ind_Ex(2,nAt-1))
    allocate(dists(nAt-1),dis_Ex(nAt-1))
    allocate(Xd(nAt,nAt))

    call makeXdgNonAdd(nAt,position, Xd)

    ! Claim to have moved atom 3; this should change 13, 23, 34, 35
    mover = 3
    call extractChangedExps(nAt,mover,Xd, indices,dists)

    ind_Ex(1,1) = 1
    ind_Ex(2,1) = 3
    ind_Ex(1,2) = 2
    ind_Ex(2,2) = 3
    ind_Ex(1,3) = 3
    ind_Ex(2,3) = 4
    ind_Ex(1,4) = 3
    ind_Ex(2,4) = 5

    do i = 1, nAt-1

      dis_Ex(i) = Xd(ind_Ex(1,i),ind_Ex(2,i))

    end do

    if( processRank == root) then

      @assertEqual(indices, ind_Ex, 'Test exp extraction')
      @assertEqual(dists, dis_Ex, regression_tolerance, 'Test exp extraction')

    end if

    deallocate(indices,ind_Ex,dists,dis_Ex)

  end subroutine test_exp_extract

  @test
  subroutine test_triPerAt()
    implicit none
    integer :: nAt=7, n, n_Ex

    call getTriPerAtom(nAt, n)

    n_Ex = 15

    if( processRank == root) then

      @assertEqual(n, n_Ex, 'Test N triplets changed per move')

    end if

  end subroutine test_triPerAt

  @test
  subroutine test_getChangedTripletsAndDists()
    implicit none
    integer :: nAt=5, nPerAt, move, i
    integer, allocatable :: triInd(:,:), tInd_Ex(:,:)
    integer, allocatable :: changeInd (:,:), cInd_Ex(:,:)

    call getTriPerAtom(nAt, nPerAt)

    allocate(triInd(3,nPerAt),tInd_Ex(3,nPerAt))
    allocate(changeInd(2,nPerAt),cInd_Ex(2,nPerAt))

    move = 1
    call getChangedTriplets(move,nAt,nPerAt, triInd)

    tInd_Ex(:,1) = (/ 1,2,3 /)
    tInd_Ex(:,2) = (/ 1,2,4 /)
    tInd_Ex(:,3) = (/ 1,2,5 /)
    tInd_Ex(:,4) = (/ 1,3,4 /)
    tInd_Ex(:,5) = (/ 1,3,5 /)
    tInd_Ex(:,6) = (/ 1,4,5 /)

    if( processRank == root) then

      @assertEqual(triInd, tInd_Ex, 'Test changed triplets #1')

    end if

    call findChangedIndPerTrip(nPerAt,triInd,move, changeInd)

    do i = 1, nPerAt

      cInd_Ex(:,i) = (/ 1,2 /)

    end do

    if( processRank == root) then

      @assertEqual(changeInd, cInd_Ex, 'Test changed dist indices #1')

    end if

    move = 3
    call getChangedTriplets(move,nAt,nPerAt, triInd)

    tInd_Ex(:,1) = (/ 1,2,3 /)
    tInd_Ex(:,2) = (/ 1,3,4 /)
    tInd_Ex(:,3) = (/ 1,3,5 /)
    tInd_Ex(:,4) = (/ 2,3,4 /)
    tInd_Ex(:,5) = (/ 2,3,5 /)
    tInd_Ex(:,6) = (/ 3,4,5 /)

    if( processRank == root) then

      @assertEqual(triInd, tInd_Ex, 'Test changed triplets #2')

    end if

    call findChangedIndPerTrip(nPerAt,triInd,move, changeInd)

    cInd_Ex(:,1) = (/ 2,3 /)
    cInd_Ex(:,2) = (/ 1,3 /)
    cInd_Ex(:,3) = (/ 1,3 /)
    cInd_Ex(:,4) = (/ 1,3 /)
    cInd_Ex(:,5) = (/ 1,3 /)
    cInd_Ex(:,6) = (/ 1,2 /)

    if( processRank == root) then

      @assertEqual(changeInd, cInd_Ex, 'Test changed dist indices #2')

    end if

    move = 5
    call getChangedTriplets(move,nAt,nPerAt, triInd)

    tInd_Ex(:,1) = (/ 1,2,5 /)
    tInd_Ex(:,2) = (/ 1,3,5 /)
    tInd_Ex(:,3) = (/ 1,4,5 /)
    tInd_Ex(:,4) = (/ 2,3,5 /)
    tInd_Ex(:,5) = (/ 2,4,5 /)
    tInd_Ex(:,6) = (/ 3,4,5 /)

    if( processRank == root) then

      @assertEqual(triInd, tInd_Ex, 'Test changed triplets #3')

    end if

    call findChangedIndPerTrip(nPerAt,triInd,move, changeInd)

    do i = 1, nPerAt

      cInd_Ex(:,i) = (/ 2,3 /)

    end do

    if( processRank == root) then

      @assertEqual(changeInd, cInd_Ex, 'Test changed dist indices #3')

    end if

  end subroutine test_getChangedTripletsAndDists

  @test
  subroutine test_atom_move()
    implicit none
  end subroutine test_atom_move
  !===========================================================================================
  @test
  subroutine test_finalize()
    call MPI_FINALIZE(ierror)
  end subroutine test_finalize



end module test_regression
